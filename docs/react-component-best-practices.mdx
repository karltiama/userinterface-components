# React Component Best Practices Guide

## Table of Contents
1. [Component Structure & Organization](#component-structure--organization)
2. [TypeScript Props & Data Types](#typescript-props--data-types)
3. [State Management](#state-management)
4. [Essential Imports](#essential-imports)
5. [Component Patterns](#component-patterns)
6. [Performance Considerations](#performance-considerations)
7. [Accessibility Best Practices](#accessibility-best-practices)
8. [Testing Considerations](#testing-considerations)

## Component Structure & Organization

### 1. File Naming Conventions
```typescript
// ✅ Good: PascalCase for components
Button.tsx
UserProfile.tsx
NavigationMenu.tsx

// ❌ Bad: camelCase or kebab-case
button.tsx
user-profile.tsx
navigationMenu.tsx
```

### 2. Component Structure Template
```typescript
// 1. Imports (external libraries first, then internal)
import React, { useState, useEffect } from 'react'
import { Link } from '@tanstack/react-router'
import { User, Settings } from 'lucide-react'

// 2. Type definitions
interface ComponentProps {
  // Define your props here
}

// 3. Component function
export default function ComponentName({ prop1, prop2 }: ComponentProps) {
  // 4. State declarations
  // 5. Effect hooks
  // 6. Event handlers
  // 7. Render logic
  return (
    // JSX
  )
}

// 8. Export (if needed for testing or other files)
export { ComponentName }
```

## TypeScript Props & Data Types

### 1. Basic Props Interface
```typescript
interface ButtonProps {
  // Required props
  children: React.ReactNode
  onClick: () => void
  
  // Optional props with default values
  variant?: 'primary' | 'secondary' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  disabled?: boolean
  
  // Complex types
  user?: {
    id: string
    name: string
    email: string
  }
  
  // Array types
  items?: string[]
  
  // Function types
  onItemClick?: (item: string, index: number) => void
  
  // Event handlers
  onMouseEnter?: (event: React.MouseEvent<HTMLButtonElement>) => void
}
```

### 2. Advanced Type Patterns
```typescript
// Generic components
interface ListProps<T> {
  items: T[]
  renderItem: (item: T, index: number) => React.ReactNode
  keyExtractor: (item: T) => string
}

// Union types for variants
type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'ghost'
type ButtonSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl'

// Discriminated unions
type AlertType = 
  | { type: 'success'; message: string }
  | { type: 'error'; message: string; code?: number }
  | { type: 'warning'; message: string; dismissible: boolean }

// Extending HTML attributes
interface CustomButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant
  loading?: boolean
}
```

### 3. Props Validation & Defaults
```typescript
// Using default parameters
export default function Button({ 
  children, 
  variant = 'primary', 
  size = 'md',
  disabled = false,
  ...props 
}: ButtonProps) {
  // Component logic
}

// Using defaultProps (legacy, prefer default parameters)
Button.defaultProps = {
  variant: 'primary',
  size: 'md',
  disabled: false
}
```

## State Management

### 1. useState Hook Patterns
```typescript
// Simple state
const [isOpen, setIsOpen] = useState(false)
const [count, setCount] = useState(0)

// Complex state with proper typing
interface UserState {
  id: string | null
  name: string
  email: string
  isLoading: boolean
  error: string | null
}

const [user, setUser] = useState<UserState>({
  id: null,
  name: '',
  email: '',
  isLoading: false,
  error: null
})

// State updates
setUser(prev => ({
  ...prev,
  isLoading: true,
  error: null
}))
```

### 2. useReducer for Complex State
```typescript
interface CounterState {
  count: number
  step: number
  history: number[]
}

type CounterAction = 
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset' }
  | { type: 'setStep'; payload: number }

function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'increment':
      return {
        ...state,
        count: state.count + state.step,
        history: [...state.history, state.count + state.step]
      }
    case 'decrement':
      return {
        ...state,
        count: state.count - state.step,
        history: [...state.history, state.count - state.step]
      }
    case 'reset':
      return { ...state, count: 0, history: [] }
    case 'setStep':
      return { ...state, step: action.payload }
    default:
      return state
  }
}

const [state, dispatch] = useReducer(counterReducer, {
  count: 0,
  step: 1,
  history: []
})
```

### 3. Custom Hooks for State Logic
```typescript
// Custom hook for form state
function useForm<T>(initialValues: T) {
  const [values, setValues] = useState<T>(initialValues)
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({})
  const [isSubmitting, setIsSubmitting] = useState(false)

  const setValue = (field: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [field]: value }))
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }))
    }
  }

  const setError = (field: keyof T, error: string) => {
    setErrors(prev => ({ ...prev, [field]: error }))
  }

  const reset = () => {
    setValues(initialValues)
    setErrors({})
    setIsSubmitting(false)
  }

  return {
    values,
    errors,
    isSubmitting,
    setIsSubmitting,
    setValue,
    setError,
    reset
  }
}
```

## Essential Imports

### 1. React Core Imports
```typescript
// Basic React imports
import React from 'react'
import { useState, useEffect, useCallback, useMemo, useRef } from 'react'

// For class components (if needed)
import React, { Component } from 'react'

// For context
import React, { createContext, useContext } from 'react'
```

### 2. Router Imports (TanStack Router)
```typescript
import { Link, useLocation, useNavigate, useParams } from '@tanstack/react-router'
import { createFileRoute } from '@tanstack/react-router'
```

### 3. Icon Libraries
```typescript
// Lucide React (recommended)
import { Home, User, Settings, ChevronDown } from 'lucide-react'

// React Icons (alternative)
import { FaHome, FaUser, FaCog } from 'react-icons/fa'
import { MdHome, MdPerson, MdSettings } from 'react-icons/md'
```

### 4. Utility Libraries
```typescript
// Date handling
import { format, parseISO, addDays } from 'date-fns'

// Data manipulation
import { debounce, throttle } from 'lodash-es'

// Validation
import { z } from 'zod'
```

## Component Patterns

### 1. Compound Components
```typescript
interface CardProps {
  children: React.ReactNode
  className?: string
}

interface CardHeaderProps {
  children: React.ReactNode
}

interface CardBodyProps {
  children: React.ReactNode
}

interface CardFooterProps {
  children: React.ReactNode
}

function Card({ children, className = '' }: CardProps) {
  return (
    <div className={`bg-white rounded-lg shadow-md ${className}`}>
      {children}
    </div>
  )
}

function CardHeader({ children }: CardHeaderProps) {
  return (
    <div className="px-6 py-4 border-b border-gray-200">
      {children}
    </div>
  )
}

function CardBody({ children }: CardBodyProps) {
  return (
    <div className="px-6 py-4">
      {children}
    </div>
  )
}

function CardFooter({ children }: CardFooterProps) {
  return (
    <div className="px-6 py-4 border-t border-gray-200">
      {children}
    </div>
  )
}

// Export as compound component
Card.Header = CardHeader
Card.Body = CardBody
Card.Footer = CardFooter

export default Card

// Usage:
// <Card>
//   <Card.Header>Title</Card.Header>
//   <Card.Body>Content</Card.Body>
//   <Card.Footer>Actions</Card.Footer>
// </Card>
```

### 2. Render Props Pattern
```typescript
interface DataFetcherProps<T> {
  url: string
  children: (data: {
    data: T | null
    loading: boolean
    error: string | null
    refetch: () => void
  }) => React.ReactNode
}

function DataFetcher<T>({ url, children }: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      const response = await fetch(url)
      const result = await response.json()
      setData(result)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setLoading(false)
    }
  }, [url])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  return <>{children({ data, loading, error, refetch: fetchData })}</>
}
```

### 3. Higher-Order Components (HOCs)
```typescript
interface WithLoadingProps {
  isLoading: boolean
}

function withLoading<P extends object>(
  Component: React.ComponentType<P>
) {
  return function WithLoadingComponent(props: P & WithLoadingProps) {
    const { isLoading, ...restProps } = props

    if (isLoading) {
      return (
        <div className="flex items-center justify-center p-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      )
    }

    return <Component {...(restProps as P)} />
  }
}
```

## Performance Considerations

### 1. Memoization
```typescript
import { memo, useMemo, useCallback } from 'react'

// Memoize expensive calculations
const ExpensiveComponent = memo(function ExpensiveComponent({ items }: { items: string[] }) {
  const sortedItems = useMemo(() => {
    return items.sort((a, b) => a.localeCompare(b))
  }, [items])

  const handleClick = useCallback((item: string) => {
    console.log('Clicked:', item)
  }, [])

  return (
    <div>
      {sortedItems.map(item => (
        <button key={item} onClick={() => handleClick(item)}>
          {item}
        </button>
      ))}
    </div>
  )
})
```

### 2. Lazy Loading
```typescript
import { lazy, Suspense } from 'react'

const LazyComponent = lazy(() => import('./LazyComponent'))

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  )
}
```

### 3. Virtual Scrolling for Large Lists
```typescript
import { FixedSizeList as List } from 'react-window'

interface VirtualListProps {
  items: string[]
  height: number
}

function VirtualList({ items, height }: VirtualListProps) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      {items[index]}
    </div>
  )

  return (
    <List
      height={height}
      itemCount={items.length}
      itemSize={35}
      width="100%"
    >
      {Row}
    </List>
  )
}
```

## Accessibility Best Practices

### 1. Semantic HTML
```typescript
// ✅ Good: Use semantic elements
function Navigation() {
  return (
    <nav role="navigation" aria-label="Main navigation">
      <ul>
        <li><a href="/home">Home</a></li>
        <li><a href="/about">About</a></li>
      </ul>
    </nav>
  )
}

// ❌ Bad: Using div for navigation
function Navigation() {
  return (
    <div>
      <div>
        <div><a href="/home">Home</a></div>
        <div><a href="/about">About</a></div>
      </div>
    </div>
  )
}
```

### 2. ARIA Attributes
```typescript
interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title: string
  children: React.ReactNode
}

function Modal({ isOpen, onClose, title, children }: ModalProps) {
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = 'unset'
    }
  }, [isOpen])

  if (!isOpen) return null

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 z-50"
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <div className="fixed inset-0 flex items-center justify-center p-4">
        <div className="bg-white rounded-lg max-w-md w-full">
          <div className="flex items-center justify-between p-4 border-b">
            <h2 id="modal-title" className="text-lg font-semibold">
              {title}
            </h2>
            <button
              onClick={onClose}
              aria-label="Close modal"
              className="text-gray-500 hover:text-gray-700"
            >
              ×
            </button>
          </div>
          <div className="p-4">
            {children}
          </div>
        </div>
      </div>
    </div>
  )
}
```

### 3. Keyboard Navigation
```typescript
function KeyboardNavigableList({ items }: { items: string[] }) {
  const [focusedIndex, setFocusedIndex] = useState(0)

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault()
        setFocusedIndex(prev => Math.min(prev + 1, items.length - 1))
        break
      case 'ArrowUp':
        event.preventDefault()
        setFocusedIndex(prev => Math.max(prev - 1, 0))
        break
      case 'Enter':
        event.preventDefault()
        console.log('Selected:', items[focusedIndex])
        break
    }
  }

  return (
    <ul
      role="listbox"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      className="focus:outline-none"
    >
      {items.map((item, index) => (
        <li
          key={item}
          role="option"
          aria-selected={index === focusedIndex}
          className={`p-2 cursor-pointer ${
            index === focusedIndex ? 'bg-blue-100' : 'hover:bg-gray-100'
          }`}
          onClick={() => setFocusedIndex(index)}
        >
          {item}
        </li>
      ))}
    </ul>
  )
}
```

## Testing Considerations

### 1. Testable Component Structure
```typescript
// Make components testable by accepting dependencies as props
interface UserProfileProps {
  user: User
  onEdit?: (user: User) => void
  onDelete?: (userId: string) => void
  // Allow injecting test dependencies
  apiClient?: ApiClient
}

function UserProfile({ user, onEdit, onDelete, apiClient = defaultApiClient }: UserProfileProps) {
  const handleEdit = () => {
    onEdit?.(user)
  }

  const handleDelete = async () => {
    if (onDelete) {
      onDelete(user.id)
    } else {
      await apiClient.deleteUser(user.id)
    }
  }

  return (
    <div>
      <h2>{user.name}</h2>
      <button onClick={handleEdit}>Edit</button>
      <button onClick={handleDelete}>Delete</button>
    </div>
  )
}
```

### 2. Data Test IDs
```typescript
function LoginForm() {
  return (
    <form>
      <input
        type="email"
        data-testid="email-input"
        placeholder="Email"
      />
      <input
        type="password"
        data-testid="password-input"
        placeholder="Password"
      />
      <button
        type="submit"
        data-testid="login-button"
      >
        Login
      </button>
    </form>
  )
}
```

## Common Patterns Summary

### 1. Component Checklist
- [ ] Proper TypeScript interfaces for props
- [ ] Default values for optional props
- [ ] Semantic HTML elements
- [ ] ARIA attributes where needed
- [ ] Keyboard navigation support
- [ ] Responsive design considerations
- [ ] Error boundaries for error handling
- [ ] Loading states
- [ ] Proper cleanup in useEffect

### 2. File Organization
```
src/
  components/
    ui/           # Reusable UI components
    forms/        # Form-specific components
    layout/       # Layout components
    features/     # Feature-specific components
  hooks/          # Custom hooks
  types/          # TypeScript type definitions
  utils/          # Utility functions
  constants/      # App constants
```

### 3. Import Order
```typescript
// 1. React and React-related imports
import React, { useState, useEffect } from 'react'

// 2. Third-party libraries
import { Link } from '@tanstack/react-router'
import { User } from 'lucide-react'

// 3. Internal imports (absolute paths)
import { Button } from '@/components/ui/Button'
import { useAuth } from '@/hooks/useAuth'

// 4. Relative imports
import './Component.css'
```

This guide covers the essential patterns and best practices for creating robust, maintainable React components. Remember to always consider accessibility, performance, and testability when building your components!

